<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=yes"><link rel="icon" type="image/png" href="/favicon.png" sizes="16x16"><link rel="stylesheet" href="/style.css"><title>A better typing accuracy format - David Bos</title></head><body class="basic-main"><header class="navigation-bar"><div id="nav-status"><img id="img-default" src="/assets/post-default.png" width="48" height="48" style="image-rendering: pixelated;"><img id="img-hover" src="/assets/post-hover.png" width="48" height="48" style="image-rendering: pixelated;"></div><nav><a href="/">HOME</a><a href="/posts">POSTS</a></nav></header><main><article class="post-article"><header><h1>A better typing accuracy format</h1><span id="published">Published on <time>15 October 2025</time></span></header><p>I was playing the demo of <a class="main-link" href="https://store.steampowered.com/app/4021860/Final_Sentence_Demo/">Final Sentence</a>, which is a last man standing typing game. The game shows you some of your statistics like WPM (words per minute) and your accuracy. Accuracy tells you what percentage of your keystrokes was correct. This got me thinking about accuracy and made me realize that it is not always a very useful metric in its usual form.</p><p>When it comes to typing accuracy it is more useful to display accuracy as how many keystrokes somebody types correctly before making a mistake. So, 1 error per N keystrokes.</p><p>Below I have listed a few accuracy values and their equivalents in this alternative format, so you can get a feeling for it.</p><ul><li>50% accuracy is 1 error per 2 keystrokes.</li><li>75% accuracy is 1 error per 4 keystrokes.</li><li>90% accuracy is 1 error per 10 keystrokes.</li><li>95% accuracy is 1 error per 20 keystrokes.</li><li>99% accuracy is 1 error per 100 keystrokes.</li></ul><p>The differences in the accuracies presented do not intuitively reflect the differences in performance; improving by 2 keystrokes can mean a big 25% accuracy improvement, but improving by 80 keystrokes can also mean a measly 4% accuracy improvement. At least half (and I am being generous here) of the available range is useless; nobody is going to be hitting more incorrect keys than correct keys. On top of that, the better you become, the harder it is to track your improvements since they translate into increasingly smaller percentage differences.</p><p>The reason for this behavior is that accuracy is the <em>inverse</em> of what you actually want. Let <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> be the total number of keystrokes (both correct and incorrect) and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> the number of incorrect keystrokes. Accuracy is is then <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, and the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> of our format is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>: basically the inverse.</p><p>Another situtation where an inverse is more useful is the usage of fps (frames per second) for tracking video game performance. If you are tasked with optimizing a game you want to track the frame time, not fps. Similar to the typing accuracy where improving by 1 keystroke does not always result in the same accuracy percentage improvement, shaving 1ms of your frame time does not always result in the same fps increase. As an example, we start with a frame time of 100ms = 10fps. We manage to shave of 40ms, giving us a frame time of 60ms = 16.7fps; a difference of 6.7fps. But, if we started with a frame time of 50ms = 20fps and we shave the same 40ms we get 10ms = 100fps; a difference of 80fps!</p></article></main><ul class="contact-information"><li><a href="https://www.github.com/toteload">Github</a></li><li><a href="mailto:me@davidbos.me">email address</a></li></ul></body></html>